<script src="https://unpkg.com/react@16/umd/react.production.min.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js" crossorigin></script>
<script src="https://unpkg.com/prop-types@15.6.2/prop-types.js" crossorigin></script>
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

#### 用于构建界面的JS库
Facebook开发且开源

#### 解决原生JS的痛点:
1、提高原生JS操作DOM（DOM-API操作UI）的效率，简化编码
Jquery仅仅简化JS原生编码，但未提高效率
2、使用JS直接操作DOM，浏览器会进行大量的重绘重排
3、原生JS没有组件化编码方案，代码复用率低
模块化（拆解js）组件化（拆解html、css、js、媒体资源等  一拆到底）

#### React的优点
原生JS命令式编程
React声明式编码
1、采用组件化模式，声明式编码，提高开发效率及组件复用率
2、在React Native中可以使用React语法进行移动端开发（前端可以通过JS去编写Android和IOS应用）
3、使用虚拟DOM 优秀的Diffing算法，尽量减少与真实DOM的交互

#### React为什么用jsx写
React.createElement 创建虚拟DOM
document.createElement 创建真实DOM

jsx能简化虚拟DOM创建！
````js
  const VDOM = (
      <h1>
        <span>hello, react</span>
      </h1>
    )
  //此虚拟DOM经过babel的翻译：const VDOM = React.createElement('h1', {id: 'title'}, React.createElement('span', {}, 'hello, react')) 就和用js创建一样 所以jsx可以说是js创建虚拟DOM的语法糖
````


#### 关于虚拟DOM：
1、虚拟DOM本质上Object类型的对象（一般对象）
2、虚拟DOM比较轻，真实DOM比较重，因为虚拟DOM是React内部在用，无需真实DOM上那么多属性
3、虚拟DOM最终会被React转化为真实DOM呈现在页面上

#### jsx语法规则：
1、定义虚拟DOM时，不要写引号
2、jsx标签中混入==JS表达式==时要用{} （不是JS语句）（区分表达式和语句：表达式有返回值会产生值，而语句不会。 测试：用一个变量去接看能不能接到值）
3、样式的类名指定不要用class，要用className
4、内联样式要用style={{color:'#fff', fontSize:'20px;}}的形式去写，外层{}表示混入JS表达式，内层{}表示写一个JS对象
5、只有一个根标签
6、标签必须要闭合
7、标签首字母：
  （1）若小写字母开头，则将该jsx标签转为html中同名元素，如html中无该标签对应的同名元素则报错
  （2）若大写字母开头， React就去渲染对应组件，若组件没有定义，则报错
8、直接给React数组，React会帮你遍历，给对象会报错


#### React组件
函数式组件：
````js
  function MyComponent() {
    console.log(this); // babel编译后开启严格模式"use strict"禁止自定义的函数中的this指向Window; this指向为undefined
    return <h2>我是用函数定义的组件（适用于【简单组件】的定义）</h2>
  }
  ReactDOM.render(<MyComponent/>, document.getElementById('test')) // React帮你调用函数

  // 执行过程
  // 1、React解析组件标签，找到MyComponent组件
  // 2、发现组件是用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM渲染在页面中
````
类式组件：
````js
  class MyComponent extends React.Component {
    // render方法放在了MyComponent类的原型对象上，供实例使用。
    render() {
      // render中的this是MyComponent类的实例对象，MyComponent组件实例对象
      console.log(this); // MyComponent {...} 控制台打印的此种形式 表示MyComponent创建的实例对象
      return (<h2>我是用类定义的组件（适用于【复杂组件】的定义）</h2>)
    }
  }
  ReactDOM.render(<MyComponent/>, document.getElementById('test'))

  // 执行过程
  // 1、React解析组件标签，找到MyComponent组件
  // 2、发现组件是用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法，将render返回的虚拟DOM转为真实DOM渲染在页面中
````


#### 组件实例的三大核心属性
（class式组件才能谈组件实例， 才有this， 排除了函数式组件）
（新版React的hooks使得函数式组件也能玩三大核心属性）


通常，在 React 中，使用构造函数仅用于以下两种情况：
1、通过给 this.state 赋值对象来初始化内部 state。
2、为事件处理函数绑定实例

关于回调 refs 的说明
如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。



#### 事件处理
````md
1、通过onXxx属性指定事件处理函数（注意大小写）
    1.1 React使用的是自定义事件（合成事件），而不是使用的原生DOM事件————为了更好的兼容性
    1.2 React中的事件是通过事件委托的方式来处理的（委托给组件最外层元素）————为了高效
2、通过event.target得到发生事件的DOM元素对象————不要过度使用ref
````

#### 受控组件和非受控组件
见demo

#### 组件生命周期（旧）
````js
  constructor(props) {}
  componentWillMount () {}
  render () {} // 常用（必用）
  componentDidMount () {} // 常用：一般做一些初始化的事，开启定时器、发送网络请求、订阅消息等
  componentWillUnmount () {} // 常用：一般做一些收尾的事，关闭定时器、取消订阅消息等
  shouldComponentUpdate () {}
  componentWillUpdate () {}
  componentDidUpdate () {}
  componentWillReceiveProps (props) {}
````
生命周期的三个阶段
````md
1、初始化阶段：由ReactDOM.render()触发——初次渲染
    1.1 constructor(props) {}
    1.2 componentWillMount () {}
    1.3 render () {}
    1.4 componentDidMount () {}
2、更新阶段：由组件内部this.setState()或父组件render触发
    1.1 shouldComponentUpdate () {}
    1.2 componentWillUpdate () {}
    1.3 render () {}
    1.4 componentDidUpdate () {}
3、卸载组件：由ReactDOM.unmountComponentAtNode()触发
    1.1 componentWillUnmount () {}
````

#### 组件生命周期（新）
即将废弃三个生命周期钩子：componentWillMount、componentWillUpdate、componentWillReceiveProps
提出两个新生命周期钩子：getDerivedStateFromProps、getSnapshotBeforeUpdate
其他环节和旧的一样
````js
  constructor(props) {}
  getDerivedStateFromProps (props, state) {} // 不常用
  render () {} // 常用（必用）
  componentDidMount () {} // 常用：一般做一些初始化的事，开启定时器、发送网络请求、订阅消息等
  componentWillUnmount () {} // 常用：一般做一些收尾的事，关闭定时器、取消订阅消息等
  shouldComponentUpdate () {}
  getSnapshotBeforeUpdate (prevProps, prevState, snapshot) {} // 不常用
  componentDidUpdate () {}
````
生命周期的三个阶段
````md
1、初始化阶段：由ReactDOM.render()触发——初次渲染
    1.1 constructor(props) {}
    1.2 getDerivedStateFromProps (props, state) {}
    1.3 render () {}
    1.4 componentDidMount () {}
2、更新阶段：由组件内部this.setState()或父组件render触发
    1.1 shouldComponentUpdate () {}
    1.2 render () {}
    1.3 getSnapshotBeforeUpdate (prevProps, prevState, snapshot) {}
    1.4 componentDidUpdate () {}
3、卸载组件：由ReactDOM.unmountComponentAtNode()触发
    1.1 componentWillUnmount () {}
````



#### key的作用
````md
1、虚拟DOM中key的作用：
   1.1 简单来说：key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用
   1.2 详细来说：当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】，随后React进行【新虚拟DOM】和【旧虚拟DOM】的diff比较，比较规则如下：
       1.2.1 旧虚拟DOM中找到了与新虚拟DOM相同的key：
             1.2.1.1 若虚拟DOM中内容没变，直接使用之前的真实DOM
             1.2.1.2 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM
       1.2.2 旧虚拟DOM中未找到与新虚拟DOM相同的key：根据数据创建新的真实DOM，随后渲染到页面中
2、index作为key可能会引发的问题：
   2.1 若对数据进行：逆序添加、逆序删除等破坏顺序的操作，会产生没有必要的真实DOM更新，界面效果没问题但效率低下
   2.2 若结构中还包含输入类的DOM，会产生错误的DOM更新，界面会出现问题
   2.3 若不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表用于展示，使用index作为key是没有问题的
3、开发中如何选择key：
   3.1 最好使用每条数据的唯一标识作为key，比如ID
   3.2 如果确定只是简单的展示数据，用index也是可以的
````


#### React脚手架
````md
  # 全局安装react脚手架
  npm i create-react-app -g

  # 创建一个基于脚手架的项目
  create-react-app demo_project

  # 进入目标文件夹运行项目
  npm start
````

#### 项目结构解析
SPA：单页面应用

* public ：存静态资源
  * favicon.ico ：页签图标
  * index.html ：应用主页面
    ````md
    %PUBLIC_URL% : 代表public文件夹路径
    <meta name="viewport"/> : 开启理想视口，用于做移动端网页的适配
    <meta name="theme-color"/> : 用于配置浏览器页签和地址栏的颜色（仅支持安卓手机浏览）
    <meta name="description"/> : 描述网站信息，用于搜索引擎收录网站
    <link rel="apple-touch-icon"/> : 用于指定网页添加到手机主屏幕后的图标（仅支持IOS手机）
    <link rel="manifest"/> : 引入应用加壳配置文件（应用加壳web网页加壳生成APP）
    <noscript></noscript> : 若浏览器不支持js时显示标签中的内容
    ````
  * manifest.json ： 应用加壳配置文件
  * robots.txt ： 爬虫规则文件
* src ：
  * App.js : App组件
  * index.js : 入口文件
  * reportWebVitals.js : 用于记录页面性能
  * setupTests.js : 用于做组件测试
  

